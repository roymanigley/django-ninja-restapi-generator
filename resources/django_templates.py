from domain_models import DomainModels, DomainModel


def get_index_html(domain_models: DomainModels) -> str:
    return f'''<html>
<head>
    <meta charset="utf-8">
    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <style>
        pre {{
            background-color: #009688;
            color: white;
            padding: 0.3em;
            border-radius: 10px;
        }}

        .toast {{
            border-radius: 10px;
        }}

        .container {{
            margin-top: 3em;
            font-size: 1.5em
        }}

        .brand-logo {{
            margin-left: 1em;
        }}
    </style>
</head>
<body>
    <nav>
      <div class="nav-wrapper teal">
        <a href="#" class="brand-logo">{domain_models.app_name}</a>
        <ul id="nav-mobile" class="right hide-on-med-and-down">
          <li><a href="/admin" target="_blank"><i class="material-icons left">admin_panel_settings</i> Admin panel</a></li>
          <li><a href="/api/docs" target="_blank"><i class="material-icons left">history_edu</i> API docs</a></li>
        </ul>
      </div>
    </nav>
    <div class="container">
        <h4>{domain_models.app_name} was generated by <a href="https://github.com/roymanigley/django-ninja-restapi-generator" target="_blank">Django Ninja REST API Generator</a></h4>
    </div>
</body>
</html>
'''


def get_docker_compose_yml(domain_models: DomainModels) -> str:
    return f'''version: '3.1'

services:
  {domain_models.app_name_snake_case}_db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: {domain_models.app_name_snake_case}_pass
      POSTGRES_USER: {domain_models.app_name_snake_case}_user
      POSTGRES_DB: {domain_models.app_name_snake_case}
    ports:
      - 5432:5432
'''


def get_build_local_script(domain_models: DomainModels) -> str:
    return f'''#!/bin/bash

echo "[+] LOCAL build started"
export APP_ENV='LOCAL'
python3 -m venv .env
source .env/bin/activate
pip install -r requirements.txt
export DJANGO_SUPERUSER_USERNAME='admin'
export DJANGO_SUPERUSER_PASSWORD='admin'
export DJANGO_SUPERUSER_EMAIL='admin@admin.local'
export DATABASE_URL='postgresql://{domain_models.app_name_snake_case}_user:{domain_models.app_name_snake_case}_pass@127.0.0.1/{domain_models.app_name_snake_case}'
python manage.py makemigrations
python manage.py migrate
python manage.py collectstatic --noinput
python manage.py createsuperuser --noinput || echo 'Superuser already exists'
echo "[+] LOCAL build completed"
'''


def get_run_local_script(domain_models: DomainModels) -> str:
    return f'''#!/bin/bash

echo "[+] starting app {domain_models.app_name_snake_case} locally"
export APP_ENV='LOCAL'
source .env/bin/activate
export DATABASE_URL='postgresql://{domain_models.app_name_snake_case}_user:{domain_models.app_name_snake_case}_pass@127.0.0.1/{domain_models.app_name_snake_case}'
python ./manage.py runserver
'''


def get_build_prod_script() -> str:
    return '''#!/bin/bash

echo "[+] PROD build started"
export APP_ENV='PROD'
pip install -r requirements.txt
export DJANGO_SUPERUSER_USERNAME="$APP_SUPERUSER_USERNAME"
export DJANGO_SUPERUSER_PASSWORD="$APP_SUPERUSER_PASSWORD"
export DJANGO_SUPERUSER_EMAIL="$APP_SUPERUSER_EMAIL"
export DJANGO_SECRET_KEY=$APP_SECRET_KEY
export DATABASE_URL=$APP_DATABASE_URL
python3 manage.py makemigrations
python3 manage.py migrate
python3 manage.py collectstatic --noinput
python3 manage.py createsuperuser --noinput || echo 'Superuser already exists'
echo "[+] PROD build completed"
'''


def get_run_prod_script(domain_models: DomainModels) -> str:
    return f'''#!/bin/bash

echo "[+] starting app {domain_models.app_name_snake_case} productive"
export APP_ENV='PROD'
export DJANGO_SECRET_KEY=$APP_SECRET_KEY
gunicorn {domain_models.app_name_snake_case}_project.wsgi:application
'''


def get_run_test_script() -> str:
    return '''#!/bin/bash

echo "[+] starting app dummy locally"
export APP_ENV='TEST'
source .env/bin/activate
export DATABASE_URL='sqlite://database.sqlite'
python ./manage.py test
'''


def get_requirements_txt() -> str:
    return '''asgiref==3.6.0
dj-database-url==2.0.0
Django==3.2.19
django-ninja==0.21.0
gunicorn==20.1.0
psycopg2-binary==2.9.6
pycryptodome==3.18.0
pydantic==1.10.7
sqlparse==0.4.4
typing_extensions==4.5.0
whitenoise==6.4.0
'''


def get_views(domain_models: DomainModels) -> str:
    rest_imports = ','.join(list(
        map(lambda entity: f'{entity.name_snake_case} as rest_{entity.name_snake_case}', domain_models.entities)))

    rest_registrations = '\n'.join(list(
        map(lambda entity: f'rest_{entity.name_snake_case}.register(api)', domain_models.entities)))
    return f'''from ninja import NinjaAPI

from {domain_models.app_name_snake_case}_app.rest import login as rest_login, errors as rest_errors, {rest_imports}
api = NinjaAPI()

rest_login.register(api)
rest_errors.register(api)
{rest_registrations}
'''


def get_error_mapping() -> str:
    return '''from django.db.utils import IntegrityError
from django.http import HttpRequest
from ninja import NinjaAPI
from ninja.errors import ValidationError


def register(api: NinjaAPI):
    @api.exception_handler(ValidationError)
    def handle_validation_error(request: HttpRequest, e: ValidationError):
        print(e)
        return api.create_response(request, {"status": "error", "detail": str(e)}, status=400)

    @api.exception_handler(IntegrityError)
    def handle_integrity_error(request: HttpRequest, e: IntegrityError):
        print(e)
        return api.create_response(request, {"status": "error", "detail": str(e)}, status=500)

    @api.exception_handler(Exception)
    def handle_general_error(request: HttpRequest, e: Exception):
        print(e)
        return api.create_response(request, {"status": "error", "detail": str(e)}, status=500)
'''


def get_rest_helper(domain_models: DomainModels) -> str:
    return f'''import datetime
from datetime import datetime, timezone

from {domain_models.app_name_snake_case}_app.rest.auth import token_to_dict


def apply_audit_infos(payload, request, create=False):
    payload_dict = payload.dict()
    token = request.headers.get('Authorization')[7:].split('.')[0]
    username = token_to_dict(token)['username']
    if create:
        payload_dict['creator'] = username
        payload_dict['create_date'] = datetime.now(tz=timezone.utc)
    payload_dict['modifier'] = username
    payload_dict['modified_date'] = datetime.now(tz=timezone.utc)
    return payload_dict
'''


def get_rest_login(domain_models: DomainModels) -> str:
    return f'''from django.http import HttpRequest
from ninja import NinjaAPI

from {domain_models.app_name_snake_case}_app.rest.auth import TokenIssuer


def register(api: NinjaAPI) -> None:

    @api.post("/login", auth=None, response={{200: dict, 401: dict}})
    def get_token(request: HttpRequest, username: str, password: str):
        try:
            token = TokenIssuer.issue_token(username, password)
            if token is not None:
                return 200, token
            else:
                return 401, {{'error': 'access denied'}}
        except Exception as e:
            print(e)
            return 401, {{'error': 'access denied'}}
'''


def get_rest_auth(domain_models: DomainModels) -> str:
    return f'''import json
import os
from base64 import b64decode, b64encode
from json import loads, dumps

from Crypto.Hash import SHA512
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5
from django.contrib.auth.models import User
from ninja.security import HttpBearer

from datetime import datetime, timedelta

from {domain_models.app_name_snake_case}_project.env import APP_TOKEN_EXPIRATION_MINUTES, APP_SECRET_KEY, APP_ENV, APP_DEBUG, APP_DATABASE_URL, APP_PRIVATE_KEY_PATH, APP_PUBLIC_KEY_PATH

with open(APP_PRIVATE_KEY_PATH) as f:
    private_key = RSA.importKey(f.read())
    print(private_key)

with open(APP_PUBLIC_KEY_PATH) as f:
    public_key = RSA.importKey(f.read())
    print(public_key)


class AuthBearer(HttpBearer):
    def authenticate(self, request, token: str) -> str or None:
        if verify_token(token):
            if is_token_expired(token):
                print(f'token expired: {{token}}')
                return None
            return token
        else:
            print(f'invalid token: {{token}}')
            return None


class TokenIssuer(object):

    @staticmethod
    def issue_token(username: str, password: str) -> dict or None:
        user: User = User.objects.get_by_natural_key(username)
        expiration_utc = datetime.utcnow() + timedelta(minutes=int(APP_TOKEN_EXPIRATION_MINUTES))
        # is_api_user = user.groups.filter(name='API_USER').exists()
        if user is not None and user.is_active and user.check_password(password):
            token_clear = dumps({{"username": username, "expiration": expiration_utc.isoformat()}})
            token = b64encode(token_clear.encode('utf-8')).decode('utf-8')
            token = sign_token(token)
            return {{"token": token}}
        return None


def token_to_dict(token: str) -> dict:
    token = token.split('.')[0]
    token_decoded = b64decode(token.encode('utf-8')).decode('utf-8')
    return loads(token_decoded)


def sign_token(token: str) -> str:
    signer = PKCS1_v1_5.new(private_key)
    hash = SHA512.new(token.encode('utf-8'))
    hash.digest()
    sign = signer.sign(hash)
    return f'{{token}}.{{sign.hex()}}'

def verify_token(token: str) -> bool:
    message, signature = token.split('.')
    hash = SHA512.new(message.encode('utf-8'))
    hash.digest()
    verifier = PKCS1_v1_5.new(public_key)
    return verifier.verify(hash, bytes.fromhex(signature))

def is_token_expired(token: str) -> bool:
    message, signature = token.split('.')
    message_decoded = b64decode(message).decode('utf-8')
    token_expiration = json.loads(message_decoded)["expiration"]
    return datetime.fromisoformat(token_expiration).timestamp() < datetime.utcnow().timestamp()
'''


def get_env_file() -> str:
    return '''import os


class MissingEnvironmentVariableException(BaseException):
    pass


# RUNTIME ENVIRONMENT VARIABLES
APP_TOKEN_EXPIRATION_MINUTES = os.getenv('TOKEN_EXPIRATION_MINUTES', 60 * 24 * 365)
APP_SECRET_KEY = os.getenv("APP_SECRET", "local-secret-JLKDSAJIOWE67DSA9878965DSADAD1234098DSASA")
APP_ENV = os.getenv("APP_ENV", "LOCAL").upper()
APP_PROD = APP_ENV == 'PROD'
APP_TEST = APP_ENV == 'TEST'
APP_DEBUG = APP_ENV != 'PROD' and os.getenv("APP_DEBUG", "FALSE").upper() == "TRUE"
APP_DATABASE_URL = os.getenv('DATABASE_URL')
APP_PRIVATE_KEY_PATH = os.getenv('RSA_PRIVATE_KEY', 'rsa_private.pem')
APP_PUBLIC_KEY_PATH = os.getenv('RSA_PUBLIC_KEY', 'rsa_public.pem')

if APP_DATABASE_URL is None:
    raise MissingEnvironmentVariableException('environment variable "DATABASE_URL" is missing')
'''


def get_read_me(domain_models: DomainModels) -> str:
    return f'''# {domain_models.app_name}
> this application was generated using [Django Ninja REST API Generator](https://github.com/roymanigley/django-ninja-restapi-generator)

## Requirements

- Python3
- venv
- docker-compose

## Initial build

### Local
> creates a default user `admin` with the password `admin`, the database is a postgresql in docker-compose which is automaticly started when the script is executed

    ./build_local.sh

### Prod 
> creates a default user according to the environment variables, some environment variables are requires, just take a look at `./build_prod.sh`

    ./build_prod.sh
    
## Run the application

### Local
> starts the application with DEBUG=True

    ./run_local.sh

### Prod
> starts the application with DEBUG=False, some environment variables are requires, just take a look at `./run_prod.sh`

    ./run_prod.sh
'''


def get_test_rest_helper(domain_models: DomainModels) -> str:
    return f'''from django.contrib.auth.models import User

from {domain_models.app_name_snake_case}_app.rest.auth import TokenIssuer


def create_active_user(username='admin', password='admin'):
    return User.objects.create_user(username=username, password=password)


def create_inactive_user(username='admin', password='admin'):
    return User.objects.create_user(username=username, password=password, is_active=False)


def get_token() -> str:
    create_active_user()
    return TokenIssuer.issue_token('admin', 'admin')["token"]
'''


def get_test_login(domain_models: DomainModels) -> str:
    return f'''from django.contrib.auth.models import User
from django.test import Client
from django.test import TestCase

from {domain_models.app_name_snake_case}_app.rest.auth import verify_token, is_token_expired
from {domain_models.app_name_snake_case}_app.tests_rest.helper import create_inactive_user, create_active_user

VALID_PASSWORD = 'password'
VALID_USERNAME = 'username'

INVALID_PASSWORD = 'wrong_password'
INVALID_USERNAME = 'wrong_username'


class LoginTest(TestCase):
    def setUp(self):
        create_active_user(VALID_USERNAME, VALID_PASSWORD)
        self.client = Client()

    def test_login_success(self):
        # WHEN
        response = self.client.post(f'/api/login?username={{VALID_USERNAME}}&password={{VALID_PASSWORD}}')

        # THEN
        self.assertEqual(response.status_code, 200)
        token = response.json()["token"]
        self.assertTrue(
            verify_token(token)
        )
        self.assertFalse(
            is_token_expired(token)
        )

    def test_inactive_user_with_correct_credentials(self):
        inactive_user_username = 'some_inactive_user'
        inactive_user_password = '1234'
        create_inactive_user(inactive_user_username, inactive_user_password)
        # WHEN
        response = self.client.post(f'/api/login?username={{inactive_user_username}}&password={{inactive_user_password}}')

        # THEN
        self.assertEqual(response.status_code, 401)
        no_token = 'token' not in response.json().keys()
        error_text = response.json()["error"]
        self.assertTrue(
            no_token
        )
        self.assertEqual(error_text, 'access denied')

    def test_login_fail_invalid_username_and_password(self):
        # WHEN
        response = self.client.post(f'/api/login?username={{INVALID_PASSWORD}}&password={{INVALID_USERNAME}}')

        # THEN
        self.assertEqual(response.status_code, 401)
        no_token = 'token' not in response.json().keys()
        error_text = response.json()["error"]
        self.assertTrue(
            no_token
        )
        self.assertEqual(error_text, 'access denied')

    def test_login_fail_invalid_password(self):
        # WHEN
        response = self.client.post(f'/api/login?username={{VALID_USERNAME}}&password={{INVALID_PASSWORD}}')

        # THEN
        self.assertEqual(response.status_code, 401)
        no_token = 'token' not in response.json().keys()
        error_text = response.json()["error"]
        self.assertTrue(
            no_token
        )
        self.assertEqual(error_text, 'access denied')

    def test_login_fail_invalid_username(self):
        # WHEN
        response = self.client.post(f'/api/login?username={{INVALID_USERNAME}}&password={{VALID_PASSWORD}}')

        # THEN
        self.assertEqual(response.status_code, 401)
        no_token = 'token' not in response.json().keys()
        error_text = response.json()["error"]
        self.assertTrue(
            no_token
        )
        self.assertEqual(error_text, 'access denied')

    def test_login_fail_valid_username_and_password_switched(self):
        # WHEN
        response = self.client.post(f'/api/login?username={{VALID_PASSWORD}}&password={{VALID_USERNAME}}')

        # THEN
        self.assertEqual(response.status_code, 401)
        no_token = 'token' not in response.json().keys()
        error_text = response.json()["error"]
        self.assertTrue(
            no_token
        )
        self.assertEqual(error_text, 'access denied')
'''


def get_entity_rest_test(domain_models: DomainModels, entity: DomainModel) -> str:
    import_dependencies = ''
    for field in entity.fields:
        if field.is_fk():
            import_dependencies += f'from {domain_models.app_name_snake_case}_app.tests_rest.tests_{field.class_type_snake_case} import {field.class_type}RestTest\n'
        if field.class_type.startswith('enum.'):
            import_dependencies += f'from {domain_models.app_name_snake_case}_app.models import {field.class_type.replace("enum.", "")}\n'
    return f'''import datetime

from django.test import Client
from django.test import TestCase
from pydantic.datetime_parse import timezone

from {domain_models.app_name_snake_case}_app.models import {entity.name}
from {domain_models.app_name_snake_case}_app.tests_rest import helper
{import_dependencies}

class {entity.name}RestTest(TestCase):
    def setUp(self):
        self.token = helper.get_token()
        self.client = Client(HTTP_AUTHORIZATION=f'Bearer {{self.token}}')

    def test_get_all(self):
        # GIVEN
        expected = self.create_persisted()
        # WHEN
        response = self.client.get('/api/{entity.name_snake_case}')
        # THEN
        self.assertEqual(response.status_code, 200)
        actual = response.json()["items"][0]
        {entity.create_assertion_for_tests()}

    def test_get_all_should_return_empty_list(self):
        # WHEN
        response = self.client.get('/api/{entity.name_snake_case}')
        # THEN
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {{"items": [], "count": 0}})

    def test_get_by_id_existing(self):
        # GIVEN
        expected = self.create_persisted()
        id = expected["id"]
        # WHEN
        response = self.client.get(f'/api/{entity.name_snake_case}/{{id}}')
        # THEN
        self.assertEqual(response.status_code, 200)
        actual = response.json()
        {entity.create_assertion_for_tests()}
        self.assertEqual(actual["id"], id)

    def test_get_by_id_non_existing(self):
        # GIVEN
        id = 999
        # WHEN
        response = self.client.get(f'/api/{entity.name_snake_case}/{{id}}')
        # THEN
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.json()["detail"], "Not Found")
        
    def test_post_valid(self):
        # GIVEN
        expected = self.create()
        # WHEN
        response = self.client.post('/api/{entity.name_snake_case}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 201)
        actual = response.json()
        id = actual["id"]
        self.assertIsNotNone(id)
        {entity.create_assertion_for_tests()}

    def test_post_invalid(self):
        # GIVEN
        expected = self.create_invalid()
        # WHEN
        response = self.client.post('/api/{entity.name_snake_case}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 400)
        
    def test_put_with_existing_valid(self):
        # GIVEN
        id = self.create_persisted()["id"]
        expected = self.create_for_update()
        # WHEN
        response = self.client.put(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 200)
        actual = response.json()
        id = actual["id"]
        self.assertIsNotNone(id)
        {entity.create_assertion_for_tests()}
        
    def test_put_existing_invalid(self):
        # GIVEN
        id = self.create_persisted()["id"]
        expected = self.create_invalid()
        # WHEN
        response = self.client.put(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 400)
        
    def test_put_non_existing(self):
        # GIVEN
        id = 999
        expected = self.create()
        # WHEN
        response = self.client.put(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 404)
        
    def test_patch_existing_valid(self):
        # GIVEN
        id = self.create_persisted()["id"]
        expected = self.create_for_update()
        # WHEN
        response = self.client.patch(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 200)
        actual = response.json()
        id = actual["id"]
        self.assertIsNotNone(id)
        {entity.create_assertion_for_tests()}
        
    def test_patch_existing_invalid(self):
        # GIVEN
        id = self.create_persisted()["id"]
        expected = self.create_invalid()
        # WHEN
        response = self.client.patch(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 500)
    
    def test_patch_non_existing(self):
        # GIVEN
        id = 999
        expected = self.create()
        # WHEN
        response = self.client.patch(f'/api/{entity.name_snake_case}/{{id}}', expected, content_type='application/json')
        # THEN
        self.assertEqual(response.status_code, 404)
    
    def test_delete_existing(self):
        # GIVEN
        id = self.create_persisted()["id"]
        # WHEN
        response = self.client.delete(f'/api/{entity.name_snake_case}/{{id}}')
        # THEN
        self.assertEqual(response.status_code, 203)
        record = {entity.name}.objects.filter(id=id).first()
        self.assertIsNone(record)

    def test_delete_non_existing(self):
        # GIVEN
        id = 999
        # WHEN
        response = self.client.delete(f'/api/{entity.name_snake_case}/{{id}}')
        # THEN
        self.assertEqual(response.status_code, 404)
    
    
    @staticmethod
    def create_persisted(model: dict = None) -> {entity.name}:
        if model is None:
            model = {entity.name}RestTest.create()
        model["modifier"] = "test"
        model["modified_date"] = datetime.datetime.now(tz=timezone.utc).isoformat()
        model["creator"] = "test"
        model["create_date"] = datetime.datetime.now(tz=timezone.utc).isoformat()
        return {entity.name}.objects.create(**model).__dict__

    @staticmethod
    def create():
        return {{
            {entity.create_valid_dictionary_entries_for_tests()}
        }}

    @staticmethod
    def create_for_update():
        return {{
            {entity.create_valid_dictionary_entries_for_update_test()}
        }}

    @staticmethod
    def create_invalid():
        return {{
            {entity.create_invalid_dictionary_entries_for_tests()}
        }}
'''


def get_entity_rest_api(domain_models: DomainModels, entity: DomainModel) -> str:
    return f'''import json
from typing import List

from django.http import HttpRequest
from django.shortcuts import get_object_or_404
from ninja import NinjaAPI
from ninja.pagination import paginate
from ninja.params import Query

from {domain_models.app_name_snake_case}_app.rest.auth import AuthBearer
from {domain_models.app_name_snake_case}_app.models import {entity.name}
from {domain_models.app_name_snake_case}_app.schemas import {entity.name}SchemaOut, {entity.name}SchemaIn, {entity.name}SchemaInPatch
from {domain_models.app_name_snake_case}_app.filters import {entity.name}FilterSchema
from {domain_models.app_name_snake_case}_app.rest.helper import apply_audit_infos


def register(api: NinjaAPI) -> None:

    @api.get("{entity.name_snake_case}", response={{200: List[{entity.name}SchemaOut]}}, auth=AuthBearer())
    @paginate()
    def get_{entity.name_snake_case}s(request: HttpRequest, filters: {entity.name}FilterSchema = Query(...)):
        return filters.filter({entity.name}.objects.all())

    @api.get("{entity.name_snake_case}/{{id}}", response={{200: {entity.name}SchemaOut}}, auth=AuthBearer())
    def get_{entity.name_snake_case}_by_id(request: HttpRequest, id: int):
        return get_object_or_404({entity.name}, id=id)

    @api.post("{entity.name_snake_case}", response={{201: {entity.name}SchemaOut}}, auth=AuthBearer())
    def create_{entity.name_snake_case}(request: HttpRequest, payload: {entity.name}SchemaIn):
        payload_dict = apply_audit_infos(payload, request, True)
        record = {entity.name}.objects.create(**payload_dict)
        return record

    @api.put("{entity.name_snake_case}/{{id}}", response={{200: {entity.name}SchemaOut}}, auth=AuthBearer())
    def update_{entity.name_snake_case}(request: HttpRequest, id: int, payload: {entity.name}SchemaIn):
        payload_dict = apply_audit_infos(payload, request)
        record = get_object_or_404({entity.name}, id=id)
        for attr, value in payload_dict.items():
            setattr(record, attr, value)
        record.save()
        return record

    @api.patch("{entity.name_snake_case}/{{id}}", response={{200: {entity.name}SchemaOut}}, auth=AuthBearer())
    def update_partial_{entity.name_snake_case}(request: HttpRequest, id: int, payload: {entity.name}SchemaInPatch):
        from_json = json.loads(request.body.decode())
        payload_dict = payload.dict()
        record = get_object_or_404({entity.name}, id=id)
        for attr, value in from_json.items():
            if attr in payload_dict.keys():
                setattr(record, attr, value if value != 'null' else None)
        payload_dict = apply_audit_infos(payload, request)
        record.save()
        return record

    @api.delete("{entity.name_snake_case}/{{id}}", response={{203: None}}, auth=AuthBearer())
    def delete_{entity.name_snake_case}(request, id: int):
        record = get_object_or_404({entity.name}, id=id)
        record.delete()
        return 203
'''


def get_filter_schema(domain_models: DomainModels) -> str:
    enum_import = ', '.join(
        list(
            map(lambda enum: enum.name,domain_models.domain_enums)
        )
    )
    if len(enum_import) > 0:
        enum_import = f'from {domain_models.app_name_snake_case}_app.models import ' + enum_import

    django_ninja_schemas = f'''from typing import Optional

from ninja import Schema, FilterSchema
from pydantic import Field
from datetime import date, datetime
{enum_import}

'''
    for entity in domain_models.entities:
        django_ninja_schemas += entity.to_django_ninja_filter_schema()
    return django_ninja_schemas


def get_entity_schema(domain_models: DomainModels) -> str:
    enum_import = ', '.join(
        list(
            map(lambda enum: enum.name, domain_models.domain_enums)
        )
    )
    if len(enum_import) > 0:
        enum_import = f'from {domain_models.app_name_snake_case}_app.models import ' + enum_import

    django_ninja_schemas = f'''from typing import Optional

from ninja import Schema
from datetime import date, datetime
{enum_import}

'''
    for entity in domain_models.entities:
        django_ninja_schemas += entity.to_django_ninja_schema()
    return django_ninja_schemas
